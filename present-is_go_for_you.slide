Is Go for you?
Exploring why and if you should learn Go.
28 Oct 2019

Loh Siu Yin
Technology Consultant, Beyond Broadcast LLP
siuyin@beyondbroadcast.com

* Mind Budget

* Mind Budget
Anything that you cannot do instinctively consumes mind budget.

We all have limited mind budget.

---

Example:

If you do not know how to drive a car.
Learning to drive consumes mind budget.

If you already do know how to drive.
Driving does not consume mind budget,
but paying attention to the changing road conditions does.

* Goals

What do you do?
What do you _want_ to do?

---

Example:
I _currently_ write stuff for the web.
I _want_ to write API servers.

* Learning consumes Mind Budget

Because I write stuff for the web,
I have _internalized_ javascript.

I can write API servers in javascript,
I still need to learn about API servers but I don't have to learn a new language.

* Choosing the right tool

Because I write backend servers in java,
I have _internalized_ java.

I want to write web frontends.
I can write web frontends in java,
I still need to learn about web frontends but I don't have to learn a new language.

.image ball-peen-hammer.jpg 96 _
Because I hammer in nails all day,
I can instinctively wield a ball-peen hammer.

I want to pull out nails.
I still need to learn about pulling out nails but I don't have to learn a new tool.

* A tool's purpose

A hammer is good for:
- driving in nails
- breaking things
- striking things

---

*Golang* is good for:
- writing backend servers
- being simple to read and understand
- having implicit interface satisfaction
- having built-in concurrency

* Go is somewhat familiar

  go: fmt.Println("Hello World!)

  c: printf("Hello World\n");

  java: System.out.println("Hello World!);

  javascript: console.log('Hello World!);

  ruby: puts 'Hello World'

  python 2: print 'Hello World'

  python 3: print('Hello World')

* Go is type-safe (1)

.play cmd/typeSafe1/main.go

* Go is type-safe (2)

.play cmd/typeSafe2/main.go

* Two sides to a coin

Strong static typing:
- allows comprehensive compile-time checks
- has stable, consistent, predictable types

Strong static typing:
- is inflexible, rigid
- not dynamic, unchanging

---

Check your internalized skills inventory
Know what you want, choose tool candidates

Decide if you wish to consume Mind Budget to learn something new.

* Go has implicitly satisfied interfaces

I define below a *Quantifier* type.
This type must have a Quantify() method that returns an integer.
Because this type is an *interface*, I do not provide a Quantify implementation.

.code cmd/intf/main.go /10 /,/20 /

I define below a *myStr* type. It is derived from go's built-in string type.
myStr type has a Quantify() method that returns an integer.

.code cmd/intf/main.go /20 /,/30 /

* Go interfaces (2)

I define below a *myInt* type derived from go's built-in int type.
myInt type has a Quantify() method that returns an integer.

.code cmd/intf/main.go /30 /,/40 /

* Go has implicitly satisfied interfaces

Will the code below work?

Can myInt / myStr type be assigned to Quantifier interface type?

.play -edit  cmd/intf/main.go /40 /,/50 /

* Consider the code below

  q = ExamPaper("https://my.school.com/siuyin.doc")
  fmt.Println(q.Quantify())

If ExamPaper is a type that has a Quantify() method that returns an integer,
we can just use it like before.

We do not have to state: ExamPaper implements Quantifier.

---

This is very useful for testing. We can have:

  q = FakeExamPaper("https://does.not.matter/siuyin.doc") // does not make internet call
  fmt.Println(q.Quantify())                               // always returns 100


* Go has built-in concurrency

The routine below prints a  "+", every second, forever. 

.code cmd/concurrency/main.go /10 /,/20 /

The routine below prints a  ".", every second, forever. 

.code cmd/concurrency/main.go /20 /,/30 /

* Concurrent plus and dot

Modify the code below to run plus and dot concurrently.

.play -edit cmd/concurrency/main.go /30 /,/40 /
